"""
This hook is called when an engine, app or framework calls 

> self.expand_show_tree(path)

Typically apps, engines and frameworks call this method
when they want to map the given path on a show tree.
The default implementation expands this path on the basis of the context of ``bundle_obj``
And would resolve to either shot/sequence/show depending on which folders exist,
"$DD_SHOWS_ROOT/$DD_SHOW/$DD_SEQ/$DD_SHOT",
"$DD_SHOWS_ROOT/$DD_SHOW/$DD_SEQ",
"$DD_SHOWS_ROOT/$DD_SHOW",
This would typically not needed to be customized.

In case customization is required, the hook is passed the app/engine/framework
that issued the original request - this gives access to configuration,
app methods, environment etc. and should allow for some sophisticated
introspection inside the hook.
"""

import os

from sgtk.util import filesystem
from sgtk import Hook


class ExpandShowTree(Hook):
    
    def execute(self, path, bundle_obj, **kwargs):
        """
        Handle expansion of the given path on show tree, depending on context issued from an app, framework or engine.
        
        :param path: path to create
        :param bundle_object: object requesting the creation. This is a legacy
                              parameter and we recommend using self.parent instead.
        """
        # this is (:) separated list of paths
        show_paths = self.expand_tree(bundle_obj, path)
        paths_list = show_paths.split(":")

        # we need to return the first path since that is the override we have configured
        # Seq:Shot:Project
        if paths_list:
            return paths_list[0]

        # none of the paths exist! the hook was configured without actually populating the show with the hook.
        return ''

    @staticmethod
    def expand_tree(bundle_obj, *paths):
        """Build search paths to form a lookup-tree where each path
        is appended to a standard location prefix starting from the
        bottom, walking up to the top.

        >>> self.expand_tree('$DD_OS/solibs', 'lib/xyz').split(":")
        ['/dd/shows/ABC/RD/cent6/solibs',
         '/dd/shows/ABC/RD/lib/xyz',
         '/dd/shows/ABC/cent6/solibs',
         '/dd/shows/ABC/tools/lib/xyz']

        The generated platform-dependent path is returned with
        variables expanded to values contained in this instance.
        The returned path is generated by invoking :meth:`buildPath`.

        """
        context = bundle_obj.context
        default_root = bundle_obj.tank.pipeline_configuration.get_primary_data_root()

        if context.project is None:
            # our context is completely empty!
            # there is no show tree to expand these paths on
            return ''

        prefixes = []
        if context.entity is None:
            # we have a project but not an entity
            prefixes.extend([
                default_root,
            ])

        if context.entity:
            # we have an entity

            if context.entity["type"] == "Sequence":
                # add the sequence paths to the mix
                prefixes.extend([
                    os.path.join(default_root, context.entity["name"]),
                    default_root,
                ])

            if context.entity["type"] == "Shot":
                entities_by_type = dict([(x["type"], x) for x in context.additional_entities])
                seq_entity = entities_by_type["Sequence"]
                # add the sequence and shot paths to the mix
                prefixes.extend([
                    os.path.join(default_root, seq_entity["name"], context.entity["name"]),
                    os.path.join(default_root, seq_entity["name"]),
                    default_root,
                ])

            # let's just support project level overrides for an Asset entity
            if context.entity["type"] == "Asset":
                prefixes.extend([
                    default_root,
                ])

        if os.environ.get("DD_TEST_BRANCHES") == "user" and os.environ.get("DD_WORKAREA"):
            branch_paths = ["user/work.$DD_WORKAREA", ""]
        elif os.environ.get("DD_TEST_BRANCHES") == "user" and not os.environ.get("DD_WORKAREA"):
            branch_paths = ["user/work.$USER", ""]
        else:
            branch_paths = []

        # this only returns us the paths that actually exist, hence enabling us to follow this search path pattern
        return filesystem.build_path(*filesystem.combine_paths(prefixes, branch_paths, paths))
